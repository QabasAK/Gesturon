unsigned int angle; // Count value of high - pertaining to the angle
unsigned char HL;   // High Low

unsigned long T1counts;
unsigned long T1time;
unsigned long Distance;

int a;
int ss;

int RR;
int FF;
int BB;
int LL;
int mode;
int xVal;
int yVal  ;
int serial =0;

void initialization();
void moveForward();
void moveBackward();
void moveLeft();
void moveRight();
void Stop();
void bluetooth_init();
void myDelay_ms(unsigned int);
void initialization();
unsigned int ATD_read(unsigned char port);
void ADC_Init();
void Delay_us(int us);
void Delay_ms(int ms);
void CCPPWM_init();
void Speed(int p);


unsigned char received_data;
const int neutralLow = 330;   // Lower bound of neutral zone
const int neutralHigh = 340; // Upper bound of neutral zone
const int forwardThreshold = 310;  // Y-axis forward movement
const int backwardThreshold = 330; // Y-axis backward movement
const int leftThreshold = 330;     // X-axis left movement
const int rightThreshold = 310;    // X-axis right movement

void myDelay_us(unsigned int);
void myDelay_ms(unsigned int);

void init_sonar(void);
void read_sonar(void);

void interrupt(void) {
     if(INTCON & 0x04){
          if(PORTD&0X10){
           mode=1;
          }else{
          mode=0;
          }

         INTCON = INTCON & 0xFB;

     }






    if (PIR1 & 0x04) { // CCP1 interrupt
       if(a==1){
        if (HL) { // High state
            CCPR1H = angle >> 8;
            CCPR1L = angle;
            HL = 0; // Switch to low state
            CCP1CON = 0x09; // Compare mode, clear output on match
            TMR1H = 0;
            TMR1L = 0;
        } else { // Low state
            CCPR1H = (40000 - angle) >> 8; // Calculate low state duration
            CCPR1L = (40000 - angle);
            CCP1CON = 0x08; // Compare mode, set output on match
            HL = 1; // Switch to high state
            TMR1H = 0;
            TMR1L = 0;
        }
         PIR1 &= 0xFB;
         }
        PIR1 &= 0xFB;// Clear CCP1 interrupt flag

    }         //VM RC7 LEDS RC6 & 5

}

void main() {
    initialization();
    ADC_Init();
    CCPPWM_init() ;


OPTION_REG = 0x87; // 32.8ms overflow
TMR0 = 0;

    TMR1H = 0;
    TMR1L = 0;

    init_sonar();              // Initialize the ultrasonic sensor
    HL = 1; // Start with high state
    CCP1CON = 0x08; // Compare mode, set output on match

    T1CON = 0x01; // Timer1 On Fosc/4 (inc 0.5µs) with no prescaler

    INTCON = 0B11100000;   // Enable global and peripheral interrupts  and Timer0 interrupt
    PIE1 |= 0x04; // Enable CCP1 interrupts

    CCPR1H = 2000 >> 8; // Initial compare value for high state
    CCPR1L = 2000;
    ss=0;
    while (1) {

    while(mode){



    xVal = ATD_read(0);  // Read x-axis
    yVal = ATD_read(1);  // Read y-axis

    if(xVal<rightThreshold){
      RR=310- xVal;
      RR=RR*2;
      RR=RR+70;
      }
      if(xVal>leftThreshold){
      LL=330- xVal;
      LL=LL*6*(-1);
      LL=LL+70;
      }
      if(yVal<forwardThreshold){
      FF=310- yVal;
      FF=FF*2;
      FF=FF+70;
      }
      if(yVal>backwardThreshold){
      BB=330- yVal;
      BB=BB*6*(-1);
      BB=BB+70;
      }

       if (xVal <= rightThreshold) {
        Stop();
                moveRight();
                Speed( RR);
        }
        else if (xVal >= leftThreshold) {
        Stop();
              moveLeft();
              Speed( LL);
        }
        else if ( yVal >= backwardThreshold) {
        Stop();
            moveBackward();
            Speed( BB);
        }
        // Left Check
        else if (yVal <= forwardThreshold) {
        Stop();
            moveForward();
            Speed( FF);
        }
        // Right Check
        else {
          Stop();
             Speed( 0);
        }
      if (PORTB & 0b00000001) { // Check if RB0 is pressed
        if(ss==0){
            a=1;
            angle = 2800; // Set angle for 90° (1.25ms pulse width)
            myDelay_ms(200);
            a=0;
            ss=1; }else{ss=ss;}
        } else{ // Check if RB1 is pressed
            if(ss){
            a=1;
            angle = 1000; // Set angle for 0° (0.5ms pulse width)
            myDelay_ms(200);
            a=0;
            ss=0; }else{ss=ss;}
        }

       read_sonar();
             myDelay_ms(200);
             if(Distance<20){
               rb5_bit=1;

             }else{
              rb5_bit=0;
             }


    }

    while(!mode) {
             Speed(200);
             read_sonar();
             myDelay_ms(200);
             if(Distance<20){
               rb5_bit=1;
             }else{
              rb5_bit=0;
             }




            if (UART1_Data_Ready()){ // Check if data is available
            received_data = UART1_Read(); // Read the received data
            switch (received_data) {
                case 'F':
                    moveForward();
                    break;
                case 'B':
                    moveBackward();
                    break;
                case 'R':
                    moveRight();
                    break;
                case 'L':
                    moveLeft();
                    break;
                default:
                    Stop();
                    break;
            }


        }

        if (PORTB & 0b00000001) { // Check if RB0 is pressed
        if(ss==0){
            a=1;
            angle = 2800; // Set angle for 90° (1.25ms pulse width)
            myDelay_ms(500);
           a=0;
            ss=1; }else{ss=ss;}
        } else{ // Check if RB1 is pressed
            if(ss){
            a=1;
            angle = 1000; // Set angle for 0° (0.5ms pulse width)
            myDelay_ms(500);
            a=0;
            ss=0;}else{ss=ss;}
        }

          }



        //Delay_ms(100);  // Delay for stability

        //servo

        //ultrasonic



        myDelay_ms(100);
    }
}
void initialization(){
    TRISC = 0b10100000; // PWM output at CCP1 (RC2)
    PORTC = 0x00;

    TRISD = 0x30; //0011 0000
    PORTD = 0x00;

    TRISB = 0x03;  // RB2 for trigger, RB1 for echo, RB0 for IR
    PORTB = 0x00;
    UART1_Init(9600);  // Initialize UART at 38600 baud rate
    Delay_ms(100);  // Allow UART stabilization
}
void CCPPWM_init(){                  // Configure CCP2 at 2ms
        T2CON = 0x07;                    // Enable Timer2 at Fosc/4 with 1:16 prescaler (8 uS percount 2000uS to count 250 counts)
        CCP2CON = 0x0C;                  // Enable PWM for CCP2
        PR2 = 250;                       // 250 counts = 8uS *250 = 2ms period
        CCPR2L = 125;                    // Buffer where we are specifying the pulse width (duty cycle)
}


void Speed(int p){
      // p = (((p>>2)*250)/255);
       CCPR2L = p;                  // PWM from RC1
}

void read_sonar(void) {
    T1CON=0x10;

    T1counts = 0;
    T1time = 0;
    Distance = 0;
    TMR1H = 0;
    TMR1L = 0;

    PORTC =PORTC | 0x10;          // Trigger the ultrasonic sensor (RB2 connected to trigger)
    myDelay_us(10);           // Keep trigger for 10uS
    PORTC =PORTC & !0X10;          // Remove trigger

    while (!(PORTC & 0x20));  // Wait until you start receiving the echo
    T1CON = 0x19;          // TMR1 ON, Fosc/4 (1uS increment) with 1:2 prescaler
    while (PORTC & 0x20);  // Wait until the pulse is received
    T1CON = 0x18;          // TMR1 OFF, Fosc/4 (1uS increment) with 1:1 prescaler

    T1counts = ((TMR1H << 8) | TMR1L);  // Get the count from Timer 1
    T1time = T1counts;     // In microseconds
    Distance = (T1time * 34) / (1000 * 2);  // Calculate distance in cm

    // Handle unreasonable distance (e.g., too large)
    if (Distance > 400) {
        Distance = 0;  // Invalid distance, reset to 0
    }

     T1CON = 0x01;
}

void init_sonar(void) {
    T1counts = 0;
    T1time = 0;
    Distance = 0;
    TMR1H = 0;
    TMR1L = 0;
    T1CON = 0x10;    // TMR1 OFF, Fosc/4 (1uS increment) with 1:2 prescaler
}
void ADC_Init() {
    ADCON1 = 0x80; // Right justify result, Vref = Vdd
    ADCON0 = 0x41; // ADC enabled, select AN0 (default), ADC ON
    TRISA = 0xFF;  // Set PORTA as input
    PORTA = 0x00;  // Initialize PORTA to zero
}

unsigned int ATD_read(unsigned char port) {
    ADCON0 = (ADCON0 & 0xC7) | (port << 3);  // Select ADC channel
    Delay_us(10);  // Allow acquisition time
    ADCON0 |= 0x04;  // Start conversion
    while (ADCON0 & 0x04);  // Wait for conversion to complete
    return ((ADRESH << 8) | ADRESL);  // Return 10-bit result
}
void moveForward() {
    PORTD = PORTD | 0x05; //0000 0101

}

void moveBackward() {
    PORTD = PORTD | 0x0A;

}

void moveRight() {
    PORTD= PORTD | 0x06;

}

void moveLeft() {
    PORTD = PORTD | 0x09;

}

void Stop() {
    PORTD = PORTD & 0x00;

}


void myDelay_ms(unsigned int ms) {
    unsigned int i, j;
    for (i = 0; i < ms; i++) {
        for (j = 0; j < 250; j++);
    }
}
void myDelay_us(unsigned int us) {
    while (us--);
}
